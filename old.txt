Negatív szám elleni védelem SetPotential stb függvényekbe?
Fontos-e, hogy kezdeti állapotba kerüljön a rendszer az idõlépés beállításakor?
Esetleg a nem mûködõ scrollbar helyére szöbegmezõt tenni, mely az idõt mutatja?
Biztos, hogy az energia-eloszlás ábrázolására a plot(..., 'o') a legjobb módszer?
Autoscale kiiktatása?
Mi a nyavalyát lehet tenni az ellen a felugró ablak ellen?
Átlagértékek lekérdezése és megjelenítése?
uiresume elõtt waitstatus vizsgálata?



set(handles.etD, 'String', num2str(handles.vals{1}))
set(handles.etM, 'String', num2str(handles.vals{2}))
set(handles.etOhm, 'String', num2str(handles.vals{3}))
set(handles.etD, 'UserData', handles.vals{1})
set(handles.etM, 'UserData', handles.vals{2})
set(handles.etOhm, 'UserData', handles.vals{3})

try
    handles.vals{1} = str2double(get(hObject,'String'));
    if handles.vals{1} <= 0
        error('Negative value')
    end
    handles.vals{3} = sqrt(handles.vals{1} / handles.vals{2});
    set(handles.etOhm, 'String', num2str(handles.vals{3}))
catch ME
    beep
    handles.vals{1} = get(handles.etD, 'UserData');
    set(handles.etD, 'String', num2str(handles.vals{1}))
    handles.vals{3} = get(handles.etOhm, 'UserData');
    set(handles.etOhm, 'String', num2str(handles.vals{3}))
end
guidata(hObject, handles)

            switch nargin
                case 0
                    oomegha = 2 * pi * 8.65E+13;
                    DD = 48;
                    mm = DD / oomegha^2;
                    energy_states = zeros(1,9);
                    energy_states(1) = 1;
                case 4
                    for i = 1 : 2 : 3
                        if ~strcmp(class(varargin{i}), 'char') || ~strcmp(class(varargin{i+1}), 'double') ||...
                                length(varargin{i+1}) > 1
                            error('QM_Oscillator cannot be created. Reason: Inappropriate parameters.')
                        end
                        switch varargin{i}
                            case 'D'
                                DD = varargin{i+1};
                            case 'm'
                                mm = varargin{i+1};
                            case 'omegha'
                                oomegha = varargin{i+1};
                            otherwise
                                error('QM_Oscillator cannot be created. Reason: Inappropriate parameters.')
                        end
                    end
                    if strcmp(varargin{1}, varargin{3})
                        error('QM_Oscillator cannot be created. Reason: Inappropriate parameters.')
                    end
                    if ~strcmp(varargin{1}, 'D') && ~strcmp(varargin{3}, 'D')
                        DD = oomegha^2 * mm;
                    elseif ~strcmp(varargin{1}, 'mm') && ~strcmp(varargin{3}, 'mm')
                        mm = DD / oomegha^2;
                    elseif ~strcmp(varargin{1}, 'oomegha') && ~strcmp(varargin{3}, 'oomegha')
                        oomegha = sqrt(DD / mm);
                    end
                    energy_states = zeros(1,9);
                    energy_states(1) = 1;
                case 5
                    for i = 1 : 2 : 3
                        if ~strcmp(class(varargin{i}), 'char') || ~strcmp(class(varargin{i+1}), 'double') ||...
                                length(varargin{i+1}) > 1
                            error('QM_Oscillator cannot be created. Reason: Inappropriate parameters.')
                        end
                        switch varargin{i}
                            case 'D'
                                DD = varargin{i+1};
                            case 'm'
                                mm = varargin{i+1};
                            case 'omegha'
                                oomegha = varargin{i+1};
                            otherwise
                                error('QM_Oscillator cannot be created. Reason: Inappropriate parameters.')
                        end
                    end
                    if strcmp(varargin{1}, varargin{3})
                        error('QM_Oscillator cannot be created. Reason: Inappropriate parameters.')
                    end
                    if ~strcmp(varargin{1}, 'D') && ~strcmp(varargin{3}, 'D')
                        DD = oomegha^2 * mm;
                    elseif ~strcmp(varargin{1}, 'mm') && ~strcmp(varargin{3}, 'mm')
                        mm = DD / oomegha^2;
                    elseif ~strcmp(varargin{1}, 'oomegha') && ~strcmp(varargin{3}, 'oomegha')
                        oomegha = sqrt(DD / mm);
                    end
                    if ~strcmp(class(varargin{5}), 'double')
                        error('QM_Oscillator cannot be created. Reason: Inappropriate parameters.')
                    end
                    energy_states = varargin{5};
                otherwise
                    error('QM_Oscillator cannot be created. Reason: Inappropriate parameters.')
            end % switch nargin



classdef ClassicProblem < handle
    properties
        Time
        TimeStep
        Period
        
        InitCond
        Energy
        PotParams
        Place
        Momentum
    end
    
    methods(Static)
        function obj = ClassicProblem()
            obj.Time = 0;
            obj.InitCond = [0 0];
            obj.Place = 0;
            obj.Momentum = 0;
            obj.Energy = 0;
        end
    end
    
    methods
        function time_step = GetTimeStep(obj)
            time_step = obj.TimeStep; end
        
        function period = GetPeriod(obj)
            period = obj.Period; end
        
        function [place, momentum, energy] = GetInitCond(obj)
            place = obj.InitCond(1); momentum = obj.InitCond(2); energy = obj.Energy; end
        
        function [place, momentum] = GetState(obj)
            place = obj.Place; momentum = obj.Momentum; end
        
        function SetTimeStep(obj, time_step)
            obj.Time = 0;
            obj.TimeStep = time_step;
            obj.Place = obj.InitCond(1);
            obj.Place = obj.InitCond(2);
        end
        function energy = SetInitCond(obj, place, momentum)
            obj.Time = 0;
            obj.InitCond(1) = place;
            obj.Place = place;
            obj.InitCond(2) = momentum;
            obj.Momentum = momentum;
            obj.Energy = obj.EstimateEnergy(place, momentum);
            energy = obj.Energy;
        end
    end
    
    methods(Abstract)
        potential = SetPotential(obj, args, place_values)
        [potential, params] = GetPotential(obj, place_values)
        StepForward(obj, count)
        StepReverse(obj, count)
        energy = EstimateEnergy(obj, place, momentum)
    end
    
    methods(Abstract, Static)
        q_variant = Quantum()
    end
end
